<h1 id="opensocket-and-closesocket-callbacks">Opensocket and closesocket callbacks</h1>
<p>Occasionally you end up in a situation where you want your application to control with more precision exactly what socket libcurl will use for its operations. libcurl offers this pair of callbacks that replaces libcurl’s own call to <code>socket()</code> and the subsequent <code>close()</code> of the same file descriptor.</p>
<h2 id="provide-a-file-descriptor">Provide a file descriptor</h2>
<p>By setting the <code>CURLOPT_OPENSOCKETFUNCTION</code> callback, you can provide a custom function to return a file descriptor for libcurl to use:</p>
<pre><code>curl_easy_setopt(handle, CURLOPT_OPENSOCKETFUNCTION, opensocket_callback);</code></pre>
<p>The <code>opensocket_callback</code> function must match this prototype:</p>
<pre><code>curl_socket_t opensocket_callback(void *clientp,
                                  curlsocktype purpose,
                                  struct curl_sockaddr *address);</code></pre>
<p>The callback gets the <em>clientp</em> as first argument, which is simply an opaque pointer you set with <code>CURLOPT_OPENSOCKETDATA</code>.</p>
<p>The other two arguments pass in data that identifies for what <em>purpose</em> and <em>address</em> the socket is to be used. The <em>purpose</em> is a typedef with a value of <code>CURLSOCKTYPE_IPCXN</code> or <code>CURLSOCKTYPE_ACCEPT</code>, basically identifying in which circumstance the socket is created. The “accept” case being when libcurl is used to accept an incoming FTP connection for when FTP active mode is used, and all other cases when libcurl creates a socket for its own outgoing connections the <em>IPCXN</em> value is passed in.</p>
<p>The <em>address</em> pointer points to a <code>struct curl_sockaddr</code> that describes the IP address of the network destination for which this socket is created. Your callback can for example use this information to whitelist or blacklist specific addresses or address ranges.</p>
<p>The socketopen callback is also explicitly allowed to modify the target address in that struct, if you would like to offer some sort of network filter or translation layer.</p>
<p>The callback should return a file descriptor or <code>CURL_SOCKET_BAD</code>, which then will cause an unrecoverable error within libcurl and it will eventually return <code>CURLE_COULDNT_CONNECT</code> from its perform function.</p>
<p>If you want to return a file descriptor that is <em>already connected</em> to a server, then you must also set the <a href="callback-sockopt.md">sockopt callback</a> and make sure that returns the correct return value.</p>
<p>The <code>curl_sockaddress</code> struct looks like this:</p>
<pre><code>struct curl_sockaddr {
  int family;
  int socktype;
  int protocol;
  unsigned int addrlen;
  struct sockaddr addr;
};</code></pre>
<h2 id="socket-close-callback">Socket close callback</h2>
<p>The corresponding callback to the open socket is of course the close socket. Usually when you provide a custom way to provide a file descriptor you want to provide your own cleanup version as well:</p>
<pre><code>curl_easy_setopt(handle, CURLOPT_CLOSEOCKETFUNCTION, closesocket_callback);</code></pre>
<p>The <code>closesocket_callback</code> function must match this prototype:</p>
<pre><code>int closesocket_callback(void *clientp, curl_socket_t item);</code></pre>
